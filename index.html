<a href="bonus.html">BONUS</a>
<!DOCTYPE html>
<html>
<head>
<title> First Assignment in HTML</title>
</head> 
<body>
<h1> Vamsidhar Reddy</h1>
<h6>ChatHouse</h6>  
<p>
    It is located in <b>Seattle,WA</b>. It is owned by an Indian.
    There are many other <b>Indian restaurants</b> around it. 
    There is an Interstate highway passing nearby it.
</p>
<hr>
<h3>Airport to ChatHouse</h3>
<h4>Tacoma International Airport is the nearest airport to ChatHouse.</h4>
<ol>
<li>From airport catch Interstate Highway 45 E road</li>
<li>after 35miles take exit 7 to kirkland</li>   
<li>kirkland to Bothell for next 5miles.
    <ol>
    <li>take East bothell</li>
    <li>reach near the second shell gas station</li>
    </ol>
</li>
<li>Walk opposite to gas station to reach ChatHouse</li>
</ol>
<h4>The food I would recommend for others to try:</h4>
<ul>
<li>Dahi Balla</li>
<li>Pav Bhaji</li>
<li>Samosa Chat</li>
<li>Pani puri</li>
</ul>
<a href="aboutme.html">About me</a>

<hr>
<h2>Sports Activities</h2>
<p>
    <h4>The table below has an information of sports, 
    location and amount to be charged to participate.</h4>
</p>
<style>
    table,td,th,tr {
      border:1px solid black;
    }
    </style>
<table>
    <tr>
        <th>Name</th>
        <th>Location</th>
        <th>Amount</th>
    </tr>
    <tr>
        <td>Badminton</td>
        <td>Rec</td>
        <td>10</td>
    </tr>
    <tr>
        <td>Basketball</td>
        <td>Indore Stadium</td>
        <td>12</td>
    </tr>
    <tr>
        <td>Cricket</td>
        <td>Stadium</td>
        <td>14</td>
    </tr>
    <tr>
        <td>Squash</td>
        <td>Rec</td>
        <td>12</td>
    </tr>
</table>
<hr>
<h3>   Dynamic programming</h3>
<blockquote cite="https://www.geeksforgeeks.org/dynamic-programming/">Dynamic Programming is mainly an optimization over plain recursion.
     Wherever we see a recursive solution that has repeated calls for same inputs, 
     we can optimize it using Dynamic Programming.
      The idea is to simply store the results of subproblems, 
      so that we do not have to re-compute them when needed later.
       This simple optimization reduces time complexities from exponential to polynomial.
       </blockquote>
       <pre>
        int m, n;
        vector<long long> dp_before(n), dp_cur(n);
        
        long long C(int i, int j);
        
        // compute dp_cur[l], ... dp_cur[r] (inclusive)
        void compute(int l, int r, int optl, int optr) {
            if (l > r)
                return;
        
            int mid = (l + r) >> 1;
            pair<long long, int> best = {LLONG_MAX, -1};
        
            for (int k = optl; k <= min(mid, optr); k++) {
                best = min(best, {(k ? dp_before[k - 1] : 0) + C(k, mid), k});
            }
        
            dp_cur[mid] = best.first;
            int opt = best.second;
        
            compute(l, mid - 1, optl, opt);
            compute(mid + 1, r, opt, optr);
        }
        
        int solve() {
            for (int i = 0; i < n; i++)
                dp_before[i] = C(0, i);
        
            for (int i = 1; i < m; i++) {
                compute(0, n - 1, 0, n - 1);
                dp_before = dp_cur;
            }
        
            return dp_before[n - 1];
        }
       </pre>
</body>  
</html>